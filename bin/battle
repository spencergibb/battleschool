#!/usr/bin/env python
#/opt/local/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python

#export PYTHONPATH=/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages

import os
import sys
import subprocess

import ansible.playbook
import ansible.constants as AC
import ansible.utils.template
from ansible import errors
from ansible import callbacks
from ansible import utils
from ansible.color import ANSIBLE_COLOR, stringc
from ansible.callbacks import display
import battleschool.constants as C

from battleschool.source.git import Git
from battleschool.source.local import Local


#TODO: verify environment: macports, ansible

def colorize(lead, num, color):
    """ Print 'lead' = 'num' in 'color' """
    if num != 0 and ANSIBLE_COLOR and color is not None:
        return "%s%s%-15s" % (stringc(lead, color), stringc("=", color), stringc(str(num), color))
    else:
        return "%s=%-4s" % (lead, str(num))


def hostcolor(host, stats, color=True):
    if ANSIBLE_COLOR and color:
        if stats['failures'] != 0 or stats['unreachable'] != 0:
            return "%-37s" % stringc(host, 'red')
        elif stats['changed'] != 0:
            return "%-37s" % stringc(host, 'yellow')
        else:
            return "%-37s" % stringc(host, 'green')
    return "%-26s" % host


def getSourceHandlers():
    handlers = [Git, Local]
    # for name, obj in inspect.getmembers(sourcepkg):
    #     if inspect.ismodule(obj):
    #         package = obj.__dict__['__package__']
    #         if package is not None and package.startswith('battleschool.source'):
    #             for srcName, srcObj in inspect.getmembers(obj):
    #                 if inspect.isclass(srcObj) and srcName != 'Source':
    #                     print "Loading %s/%s" % (srcName, srcObj)
    #                     handlers.append(srcObj)
    return handlers


def main(args):

    battleschool_dir = "%s/.battleschool" % os.environ['HOME']

    AC.DEFAULT_HOST_LIST = C.DEFAULT_HOST_LIST

    # create parser for CLI options
    usage = "%prog"
    parser = utils.base_parser(
        constants=AC,
        usage=usage,
        connect_opts=True,
        runas_opts=True,
        subset_opts=True,
        check_opts=True,
        diff_opts=True,
        output_opts=True
    )
    parser.add_option('-e', '--extra-vars', dest="extra_vars", default=None,
                      help="set additional key=value variables from the CLI")
    parser.add_option('--tags', dest='tags', default='all',
                      help="only run plays and tasks tagged with these values")
    # FIXME: list hosts is a common option and can be moved to utils/__init__.py
    parser.add_option('--list-hosts', dest='listhosts', action='store_true',
                      help="dump out a list of hosts, each play will run against, does not run playbook!")
    parser.add_option('--syntax-check', dest='syntax', action='store_true',
                      help="do a playbook syntax check on the playbook, do not execute the playbook")
    parser.add_option('--list-tasks', dest='listtasks', action='store_true',
                      help="do list all tasks that would be executed")
    parser.add_option('--step', dest='step', action='store_true',
                      help="one-step-at-a-time: confirm each task before running")
    parser.add_option('--config-dir', dest='config_dir', default=None,
                      help="config directory for battleschool (default=%s)" % battleschool_dir)

    options, args = parser.parse_args(args)

    playbooks_to_run = [C.DEFAULT_PLAYBOOK]

    inventory = ansible.inventory.Inventory(options.inventory)
    inventory.subset(options.subset)
    if len(inventory.list_hosts()) == 0:
        raise errors.AnsibleError("provided hosts list is empty")

    sshpass = None
    sudopass = None
    if not options.listhosts and not options.syntax and not options.listtasks:
        options.ask_pass = AC.DEFAULT_ASK_PASS
        options.ask_sudo_pass = options.ask_sudo_pass or AC.DEFAULT_ASK_SUDO_PASS
        ( sshpass, sudopass ) = utils.ask_passwords(ask_pass=options.ask_pass, ask_sudo_pass=options.ask_sudo_pass)
        if options.sudo_user or options.ask_sudo_pass:
            options.sudo = True
        options.sudo_user = options.sudo_user or AC.DEFAULT_SUDO_USER
    if options.extra_vars and options.extra_vars[0] in '[{':
        extra_vars = utils.json_loads(options.extra_vars)
    else:
        extra_vars = utils.parse_kv(options.extra_vars)
    only_tags = options.tags.split(",")

    if options.config_dir:
        battleschool_dir = options.config_dir
    else:
        options.config_dir = battleschool_dir

    config_data = utils.parse_yaml_from_file("%s/config.yml" % battleschool_dir)
    options.cache_dir = "%s/cache" % battleschool_dir

    output = subprocess.check_output(["/usr/bin/sw_vers", "-productVersion"])
    mac_version = output.split()[-1].split(".")

    if extra_vars is None:
        extra_vars = dict()

    extra_vars['mac_version'] = mac_version
    extra_vars['mac_major_minor_version'] = "%s.%s" % (mac_version[0], mac_version[1])

    handlers = getSourceHandlers()

    if options.module_path is None:
        options.module_path = AC.DEFAULT_MODULE_PATH

    if C.DEFAULT_MODULE_PATH not in options.module_path:
        options.module_path = "%s:%s" % (C.DEFAULT_MODULE_PATH, options.module_path)

    if 'sources' in config_data:
        sources = config_data['sources']

        for handler in handlers:
            source = handler(options, sources)
            playbooks = source.run(inventory, sshpass, sudopass)
            for playbook in playbooks:
                playbooks_to_run.append(playbook)

    for playbook in playbooks_to_run:
        if not os.path.exists(playbook):
            raise errors.AnsibleError("the playbook: %s could not be found" % playbook)
        if not os.path.isfile(playbook):
            raise errors.AnsibleError("the playbook: %s does not appear to be a file" % playbook)

    # run all playbooks specified on the command line
    for playbook in playbooks_to_run:

        # let inventory know which playbooks are using so it can know the basedirs
        inventory.set_playbook_basedir(os.path.dirname(playbook))

        stats = callbacks.AggregateStats()
        playbook_cb = callbacks.PlaybookCallbacks(verbose=utils.VERBOSITY)
        if options.step:
            playbook_cb.step = options.step
        runner_cb = callbacks.PlaybookRunnerCallbacks(stats, verbose=utils.VERBOSITY)

        pb = ansible.playbook.PlayBook(
            playbook=playbook,
            module_path=options.module_path,
            inventory=inventory,
            forks=options.forks,
            remote_user=options.remote_user,
            remote_pass=sshpass,
            callbacks=playbook_cb,
            runner_callbacks=runner_cb,
            stats=stats,
            timeout=options.timeout,
            transport=options.connection,
            sudo=options.sudo,
            sudo_user=options.sudo_user,
            sudo_pass=sudopass,
            extra_vars=extra_vars,
            private_key_file=options.private_key_file,
            only_tags=only_tags,
            check=options.check,
            diff=options.diff
        )

        if options.listhosts or options.listtasks:
            print ''
            print 'playbook: %s' % playbook
            print ''
            playnum = 0
            for (play_ds, play_basedir) in zip(pb.playbook, pb.play_basedirs):
                playnum += 1
                play = ansible.playbook.Play(pb, play_ds, play_basedir)
                label = play.name
                if options.listhosts:
                    hosts = pb.inventory.list_hosts(play.hosts)
                    print '  play #%d (%s): host count=%d' % (playnum, label, len(hosts))
                    for host in hosts:
                        print '    %s' % host
                if options.listtasks:
                    matched_tags, unmatched_tags = play.compare_tags(pb.only_tags)
                    unmatched_tags.discard('all')
                    unknown_tags = set(pb.only_tags) - (matched_tags | unmatched_tags)
                    if unknown_tags:
                        continue
                    print '  play #%d (%s): task count=%d' % (playnum, label, len(play.tasks()))
                    for task in play.tasks():
                        if set(task.tags).intersection(pb.only_tags):
                            if getattr(task, 'name', None) is not None:
                                # meta tasks have no names
                                print '    %s' % task.name
                print ''
            continue

        if options.syntax:
            # if we've not exited by now then we are fine.
            print 'Playbook Syntax is fine'
            return 0

        failed_hosts = []

        try:

            pb.run()

            hosts = sorted(pb.stats.processed.keys())
            display(callbacks.banner("PLAY RECAP"))
            playbook_cb.on_stats(pb.stats)

            for h in hosts:
                t = pb.stats.summarize(h)
                if t['unreachable'] > 0 or t['failures'] > 0:
                    failed_hosts.append(h)

            if len(failed_hosts) > 0:
                filename = pb.generate_retry_inventory(failed_hosts)
                if filename:
                    display("           to retry, use: --limit @%s\n" % filename)

            for h in hosts:
                t = pb.stats.summarize(h)

                display("%s : %s %s %s %s" % (
                    hostcolor(h, t),
                    colorize('ok', t['ok'], 'green'),
                    colorize('changed', t['changed'], 'yellow'),
                    colorize('unreachable', t['unreachable'], 'red'),
                    colorize('failed', t['failures'], 'red')),
                        screen_only=True
                )

                display("%s : %s %s %s %s" % (
                    hostcolor(h, t, False),
                    colorize('ok', t['ok'], None),
                    colorize('changed', t['changed'], None),
                    colorize('unreachable', t['unreachable'], None),
                    colorize('failed', t['failures'], None)),
                        log_only=True
                )


            print ""
            if len(failed_hosts) > 0:
                return 2

        except errors.AnsibleError, e:
            display("ERROR: %s" % e, color='red')
            return 1


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
