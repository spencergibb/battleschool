#!/usr/bin/python
# -*- coding: utf-8 -*-

DOCUMENTATION = '''
---
module: mac_pkg
author: Spencer Gibb
short_description: Installs Mac pkg files
description:
    - Installs Mac pkg files, optionally mounting/unmounting dmg
version_added: "1.1"
options:
    state:
        description:
            - state of the package
        choices: [ 'present', 'absent' ]
        required: false
        default: present
notes:  []
'''
EXAMPLES = '''
- mac_pkg: name=foo state=present
- mac_pkg: name=foo state=present update_cache=yes
'''

import abc
import os
import shutil
import tempfile

from os import path


class Archive(object):

    __metaclass__ = abc.ABCMeta

    def __init__(self, module, pkg):
        self.module = module
        self.params = module.params
        self.curl_path = module.get_bin_path('curl', True, ['/usr/bin'])
        self.pkg = pkg
        return

    @abc.abstractmethod
    def open(self):
        """ Open the archive """

    def pkg_path(self):
        return self._pkg_path

    def clone(self):
        """ close the archive """
        pass

    def acquire(self):
        if exists(self.params, 'src'):
            src = self.params['src']

            self._pkg_path = src
            # module.exit_json(changed=False, msg="src: '%s'" % src)
        else:
            #get pkg from url
            #wget --no-cookies --no-check-certificate --directory-prefix=${WORK_DIR} -c --header "Cookie: $COOKIE" ${URL}
            #wget --no-cookies --no-check-certificate --directory-prefix=${WORK_DIR} -c ${URL}
            #curl --location --insecure --cookie gpw_e24=http%3A%2F%2Fwww.oracle.com
            #TODO: verify url
            url = self.params['url']

            curl_opts = ""

            if exists(self.params, 'curl_opts'):
                curl_opts = self.params['curl_opts']

            #TODO: use environment variable to override cachedir
            download_dir = path.expanduser("~/.battleschool/cache/downloads")
            if not path.exists(download_dir):
                os.makedirs(download_dir)

            output_opts = ""
            pre_cmd = ""

            #TODO: verify write perms of dest parent
            # if exists(self.params, 'dest'):
            dest = self.params['dest']

            if not path.isabs(dest):
                dest = "%s/%s" % (download_dir, dest)

            output_opts = "--output %s" % dest
            # else:
            #     pre_cmd = "cd %s && " % download_dir
            #     output_opts = "--remote-name --remote-header-name"

            # self.module.exit_json(changed=False, msg="pre_cmd %s, output_opts %s, curl_opts %s"
            #                                          % (pre_cmd, output_opts, curl_opts))

            #force delete
            if path.exists(dest) and self.params['force']:
                os.unlink(dest)

            if not path.exists(dest):
                rc, out, err = self.module.run_command("%s %s --insecure --silent --location %s %s %s" %
                                                       (pre_cmd, self.curl_path, output_opts, curl_opts, url))
                if rc > 0:
                    self.module.fail_json(msg="failed to install %s: %s\n\t%s" % (self.pkg.name(), out, err))

            self._pkg_path = dest


class ZipArchive(Archive):

    def __init__(self, module, pkg):
        super(ZipArchive, self).__init__(module, pkg)
        self.unzip_path = module.get_bin_path('unzip', True, ['/usr/bin'])
        #TODO: override target_dir
        self.target_dir = tempfile.mkdtemp(suffix='-zip-extract', prefix='mac_pkg-')

    def open(self):
        # self.module.exit_json(changed=False, msg="unzip_path %s, pkg_path %s, target_dir %s, archive_path %s"
        #       % (self.unzip_path, self.pkg_path(), self.target_dir, self.params['archive_path']))
        rc, out, err = self.module.run_command("%s %s -d %s" % (self.unzip_path, self.pkg_path(), self.target_dir))
        if rc > 0:
            self.module.fail_json(msg="failed to unzip %s: %s\n\t%s" % (self.pkg_path(), out, err))
        self._pkg_path = "%s/%s" % (self.target_dir, self.params['archive_path'])

    def close(self):
        shutil.rmtree(self.target_dir)


class DmgArchive(Archive):

    def __init__(self, module, pkg):
        super(DmgArchive, self).__init__(module, pkg)
        self.hdiutil_path = module.get_bin_path('hdiutil', True, ['/usr/bin'])
        self.dmg_volume = None

    def open(self):
        #if dmg mount and record volume path
        #hdiutil attach Vagrant-1.3.0.dmg | grep Volumes | awk '{print $3}'
        rc, out, err = self.module.run_command("%s attach %s | grep Volumes" % (self.hdiutil_path, self._pkg_path))
        if rc > 0:
            self.module.fail_json(msg="failed to install %s: %s\n\t%s" % (self.pkg.name(), out, err))

        idx = out.index("/Volumes/")
        self.dmg_volume = out[idx:].strip()
        archive_path = self.params['archive_path']
        self._pkg_path = "\"%s\"/\"%s\"" % (self.dmg_volume, archive_path)
        # self.module.exit_json(changed=False, msg="pkg_path %s, archive_path %s" % (self.pkg_path, archive_path))

    def close(self):
        rc, out, err = self.module.run_command("%s unmount \"%s\"" % (self.hdiutil_path, self.dmg_volume))
        if rc > 0:
            self.module.fail_json(msg="failed to install %s: %s\n\t%s" % (self.pkg.name(), out, err))


class NoneArchive(Archive):

    def open(self):
        pass

    def close(self):
        pass


class Package(object):

    __metaclass__ = abc.ABCMeta

    def __init__(self, module):
        self.module = module
        self.params = module.params
        return

    @abc.abstractmethod
    def install(self, pkg_path):
        """ Install the package """

    @abc.abstractmethod
    def is_installed(self):
        """ Is the package installed """

    @abc.abstractmethod
    def name(self):
        """ the name of the package """

    @abc.abstractmethod
    def version(self):
        """ the version of the package """


class PkgPackage(Package):

    def __init__(self, module):
        super(PkgPackage, self).__init__(module)
        self.installer_path = module.get_bin_path('installer', True, ['/usr/sbin'])
        self.pkgutil_path = module.get_bin_path('pkgutil', True, ['/usr/sbin'])

        #find installed version
        self._pkg_name = self.params['pkg_name']
        rc, out, err = module.run_command("%s --pkg-info=%s 2>&1 |grep version| awk '{print $2}'" %
                                          (self.pkgutil_path, self._pkg_name))
        if rc > 0:
            module.fail_json(msg="failed to install %s: %s %s" % (self._pkg_name, out, err))

        self._version = out.strip()

    def install(self, pkg_path):
        #install package file
        #installer -pkg "${PGK_DIR}"/"${PKG_FILE}" -target /
        #TODO: support target param
        rc, out, err = self.module.run_command("%s -pkg %s -target /" % (self.installer_path, pkg_path))
        if rc > 0:
            self.module.fail_json(msg="failed to install %s: %s %s" % (pkg_path, out, err))

    def is_installed(self):
        pkg_version = None
        if exists(self.params, 'pkg_version'):
            pkg_version = self.params['pkg_version']

        if pkg_version is not None:
            return self._version == pkg_version

        if self._version:
            return True

        return False

    def name(self):
        return self._pkg_name

    def version(self):
        return self._version


class AppPackage(Package):

    def __init__(self, module):
        super(AppPackage, self).__init__(module)
        if exists(self.params, 'app_creates'):
            self._app_creates = self.params['app_creates']
        elif exists(self.params, 'archive_path'):
            # TODO: parameterize app destination
            self._app_creates = '/Applications/%s' % self.params['archive_path']
        else:
            self.module.fail_json(msg="for pkg_type=app one of app_creates or archive_path must not be empty")

    def install(self, pkg_path):
        shutil.copytree(pkg_path, self._app_creates)

    def is_installed(self):
        return path.exists(self._app_creates)

    def name(self):
        return self._app_creates

    def version(self):
        return "N/A"


def exists(dict, key):
    """ is key in dict and is dict[key] not none """
    if key in dict and dict[key] is not None:
        return True

    return False


class Installer(object):

    def __init__(self, module):
        self.module = module
        self.params = module.params

    def install(self):
        pkg = self._instantiate('pkg_type', 'Package')

        if pkg.is_installed():
            self.module.exit_json(changed=False, version=pkg.version(), msg="package %s already present" % pkg.name())
        else:

            archive = self._instantiate('archive_type', 'Archive', pkg)

            archive.acquire()

            archive.open()

            pkg.install(archive.pkg_path())

            archive.close()
            #self.module.exit_json(changed=False, msg="pkg %s, archive %s" % (pkg, archive))
            self.module.exit_json(changed=True,  version=pkg.version(), msg="installed package %s" % pkg.name())

    def _instantiate(self, class_key, class_suffix, pkg=None):
        class_name = "%s%s" % (self.params[class_key].title(), class_suffix)
        m = __import__(self.__module__)
        klass = getattr(m, class_name)

        if pkg is None:
            instance = klass(self.module)
        else:
            instance = klass(self.module, pkg)

        return instance

    def validate(self):
        if self.params['pkg_type'] == "app" and self.params['archive_type'] == "none":
            self.module.fail_json(msg="pkg_type can not = 'app' with archive_type = 'none'")

        if not exists(self.params, 'src') and not exists(self.params, 'url'):
            self.module.fail_json(msg="one of src or url must not be empty")


def main():
    module = AnsibleModule(
        argument_spec=dict(
            state=dict(default="present", choices=["present", "installed"]),
            archive_type=dict(default="none", choices=["zip", "dmg", "none"]),
            src=dict(aliases=["source"], required=False),
            url=dict(aliases=[], required=False),
            dest=dict(aliases=["destination"], required=False),
            force=dict(default='no', type='bool'),
            curl_opts=dict(aliases=[], required=False),
            archive_path=dict(required=False),
            pkg_type=dict(default="pkg", choices=["pkg", "app"]),
            pkg_name=dict(required=False),
            pkg_version=dict(required=False),
            app_creates=dict(required=False),
        )
    )

    p = module.params

    installer = Installer(module)

    installer.validate()

    if p["state"] in ["present", "installed"]:
        installer.install()

    #TODO: implement remove
    elif p["state"] in ["absent", "removed"]:
    #remove_package(module, pkgutil_path, pkg)
        module.fail_json(changed=False, msg="remove package %s, using %s NOT IMPLEMENTED" % (pkg, pkgutil_path))

# this is magic, see lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>

main()
